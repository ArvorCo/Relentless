/**
 * Project Scaffolder
 *
 * Creates Relentless files in a project's relentless/ directory
 *
 * Structure:
 * relentless/
 * â”œâ”€â”€ config.json
 * â”œâ”€â”€ prompt.md
 * â””â”€â”€ features/
 *     â””â”€â”€ <feature-name>/
 *         â”œâ”€â”€ prd.md
 *         â”œâ”€â”€ prd.json
 *         â””â”€â”€ progress.txt
 *
 * Best practices:
 * - All relentless files go in relentless/ subdirectory
 * - Each feature gets its own folder with prd.md, prd.json, progress.txt
 * - Only skills are installed to .claude/skills/ (expected by Claude Code)
 * - Does not modify project root files (CLAUDE.md, AGENTS.md, etc.)
 */

import { existsSync, mkdirSync } from "node:fs";
import { join } from "node:path";
import chalk from "chalk";
import { checkAgentHealth } from "../agents/registry";
import { DEFAULT_CONFIG } from "../config/schema";

/**
 * Get the relentless root directory
 * Works for both:
 * - Development: /path/to/relentless/src/init -> /path/to/relentless
 * - Global install: /usr/local/lib/node_modules/@arvorco/relentless/src/init -> /usr/local/lib/node_modules/@arvorco/relentless
 */
function getRelentlessRoot(): string {
  // import.meta.dir is the directory of this file (src/init/)
  const currentDir = import.meta.dir;
  
  // Remove /src/init from the end
  if (currentDir.endsWith("/src/init")) {
    return currentDir.replace("/src/init", "");
  }
  
  // Fallback: go up two directories
  return join(currentDir, "..", "..");
}

const relentlessRoot = getRelentlessRoot();

/**
 * Files to create in the relentless/ directory
 * These can be force-updated with -f flag
 */
const RELENTLESS_FILES: Record<string, () => string> = {
  "config.json": () => JSON.stringify(DEFAULT_CONFIG, null, 2),
};

/**
 * Default progress.txt content for a new feature with YAML frontmatter
 */
export function createProgressTemplate(featureName: string): string {
  const started = new Date().toISOString();
  return `---
feature: ${featureName}
started: ${started}
last_updated: ${started}
stories_completed: 0
patterns: []
---

# Progress Log: ${featureName}

## Codebase Patterns

<!-- Patterns discovered during development will be added here -->

---
`;
}

/**
 * Initialize Relentless in a project
 */
export async function initProject(projectDir: string = process.cwd(), force: boolean = false): Promise<void> {
  console.log(chalk.bold.blue(`\nðŸš€ ${force ? "Reinstalling" : "Initializing"} Relentless\n`));

  // Check installed agents
  console.log(chalk.dim("Detecting installed agents..."));
  const health = await checkAgentHealth();
  const installed = health.filter((h) => h.installed);

  console.log(`\nFound ${chalk.green(installed.length)} installed agents:`);
  for (const agent of installed) {
    console.log(`  ${chalk.green("âœ“")} ${agent.displayName}`);
  }

  const notInstalled = health.filter((h) => !h.installed);
  if (notInstalled.length > 0) {
    console.log(chalk.dim(`\nNot installed: ${notInstalled.map((a) => a.displayName).join(", ")}`));
  }

  // Create relentless directory structure
  const relentlessDir = join(projectDir, "relentless");
  const featuresDir = join(relentlessDir, "features");

  for (const dir of [relentlessDir, featuresDir]) {
    if (!existsSync(dir)) {
      mkdirSync(dir, { recursive: true });
    }
  }

  // Create relentless files (can be force-updated)
  console.log(chalk.dim("\nCreating relentless files..."));

  for (const [filename, contentFn] of Object.entries(RELENTLESS_FILES)) {
    const path = join(relentlessDir, filename);

    if (existsSync(path) && !force) {
      console.log(`  ${chalk.yellow("âš ")} relentless/${filename} already exists, skipping`);
      continue;
    }

    await Bun.write(path, contentFn());
    const action = existsSync(path) && force ? "updated" : "created";
    console.log(`  ${chalk.green("âœ“")} relentless/${filename} ${force ? `(${action})` : ""}`);
  }

  // Note: constitution.md and prompt.md are NOT created here
  // They should be generated by /relentless.constitution command
  // This ensures each project gets personalized governance and agent instructions

  // Create features directory with .gitkeep
  const gitkeepPath = join(featuresDir, ".gitkeep");
  if (!existsSync(gitkeepPath)) {
    await Bun.write(gitkeepPath, "");
    console.log(`  ${chalk.green("âœ“")} relentless/features/.gitkeep`);
  }

  // Copy skills to .claude/skills/ (this is expected by Claude Code)
  console.log(chalk.dim("\nInstalling skills..."));
  const skillsDir = join(projectDir, ".claude", "skills");
  if (!existsSync(skillsDir)) {
    mkdirSync(skillsDir, { recursive: true });
  }

  const sourceSkillsDir = join(relentlessRoot, ".claude", "skills");

  if (!existsSync(sourceSkillsDir)) {
    console.error(chalk.red(`\nâŒ Error: Skills directory not found at ${sourceSkillsDir}`));
    console.error(chalk.red(`   Relentless root: ${relentlessRoot}`));
    console.error(chalk.red(`   This may indicate an installation problem.`));
    console.error(chalk.dim(`\n   If you installed globally, the package may be at:`));
    console.error(chalk.dim(`   - /usr/local/lib/node_modules/@arvorco/relentless`));
    console.error(chalk.dim(`   - ~/.bun/install/global/node_modules/@arvorco/relentless`));
    console.error(chalk.dim(`\n   Try reinstalling: npm install -g @arvorco/relentless\n`));
    process.exit(1);
  }

  // List of skills to install (used for both Claude Code and Amp)
  const skills = [
    "prd",
    "relentless",
    "constitution",
    "specify",
    "plan",
    "tasks",
    "checklist",
    "clarify",
    "analyze",
    "implement",
    "taskstoissues",
  ];

  if (existsSync(sourceSkillsDir)) {
    for (const skill of skills) {
      const sourcePath = join(sourceSkillsDir, skill);
      const destPath = join(skillsDir, skill);

      if (!existsSync(sourcePath)) {
        console.log(`  ${chalk.red("âœ—")} .claude/skills/${skill} - source not found`);
        continue;
      }

      if (existsSync(destPath) && !force) {
        console.log(`  ${chalk.yellow("âš ")} .claude/skills/${skill} already exists, skipping`);
      } else {
        try {
          if (existsSync(destPath) && force) {
            await Bun.spawn(["rm", "-rf", destPath]).exited;
          }
          const result = await Bun.spawn(["cp", "-r", sourcePath, destPath]).exited;
          if (result !== 0) {
            console.log(`  ${chalk.red("âœ—")} .claude/skills/${skill} - copy failed`);
            continue;
          }
          const action = force ? "updated" : "created";
          console.log(`  ${chalk.green("âœ“")} .claude/skills/${skill} (${action})`);
        } catch (error) {
          console.log(`  ${chalk.red("âœ—")} .claude/skills/${skill} - error: ${error}`);
        }
      }
    }
  }

  // Copy skills to .amp/skills/ if Amp is installed
  const ampInstalled = installed.some((a) => a.name === "amp");
  if (ampInstalled) {
    console.log(chalk.dim("\nInstalling skills for Amp..."));
    const ampSkillsDir = join(projectDir, ".amp", "skills");
    if (!existsSync(ampSkillsDir)) {
      mkdirSync(ampSkillsDir, { recursive: true });
    }

    for (const skill of skills) {
      const sourcePath = join(sourceSkillsDir, skill);
      const destPath = join(ampSkillsDir, skill);

      if (!existsSync(sourcePath)) {
        continue;
      }

      if (existsSync(destPath) && !force) {
        console.log(`  ${chalk.yellow("âš ")} .amp/skills/${skill} already exists, skipping`);
      } else {
        try {
          if (existsSync(destPath) && force) {
            await Bun.spawn(["rm", "-rf", destPath]).exited;
          }
          const result = await Bun.spawn(["cp", "-r", sourcePath, destPath]).exited;
          if (result !== 0) {
            console.log(`  ${chalk.red("âœ—")} .amp/skills/${skill} - copy failed`);
            continue;
          }
          const action = force ? "updated" : "created";
          console.log(`  ${chalk.green("âœ“")} .amp/skills/${skill} (${action})`);
        } catch (error) {
          console.log(`  ${chalk.red("âœ—")} .amp/skills/${skill} - error: ${error}`);
        }
      }
    }
  }

  // Copy skills to .opencode/skill/ if OpenCode is installed (SINGULAR!)
  const opencodeInstalled = installed.some((a) => a.name === "opencode");
  if (opencodeInstalled) {
    console.log(chalk.dim("\nInstalling skills for OpenCode..."));
    const opencodeSkillsDir = join(projectDir, ".opencode", "skill");
    if (!existsSync(opencodeSkillsDir)) {
      mkdirSync(opencodeSkillsDir, { recursive: true });
    }

    for (const skill of skills) {
      const sourcePath = join(sourceSkillsDir, skill);
      const destPath = join(opencodeSkillsDir, skill);

      if (!existsSync(sourcePath)) {
        continue;
      }

      if (existsSync(destPath) && !force) {
        console.log(`  ${chalk.yellow("âš ")} .opencode/skill/${skill} already exists, skipping`);
      } else {
        try {
          if (existsSync(destPath) && force) {
            await Bun.spawn(["rm", "-rf", destPath]).exited;
          }
          const result = await Bun.spawn(["cp", "-r", sourcePath, destPath]).exited;
          if (result !== 0) {
            console.log(`  ${chalk.red("âœ—")} .opencode/skill/${skill} - copy failed`);
            continue;
          }
          const action = force ? "updated" : "created";
          console.log(`  ${chalk.green("âœ“")} .opencode/skill/${skill} (${action})`);
        } catch (error) {
          console.log(`  ${chalk.red("âœ—")} .opencode/skill/${skill} - error: ${error}`);
        }
      }
    }
  }

  // Copy skills to .codex/skills/ if Codex is installed
  const codexInstalled = installed.some((a) => a.name === "codex");
  if (codexInstalled) {
    console.log(chalk.dim("\nInstalling skills for Codex..."));
    const codexSkillsDir = join(projectDir, ".codex", "skills");
    if (!existsSync(codexSkillsDir)) {
      mkdirSync(codexSkillsDir, { recursive: true });
    }

    for (const skill of skills) {
      const sourcePath = join(sourceSkillsDir, skill);
      const destPath = join(codexSkillsDir, skill);

      if (!existsSync(sourcePath)) {
        continue;
      }

      if (existsSync(destPath) && !force) {
        console.log(`  ${chalk.yellow("âš ")} .codex/skills/${skill} already exists, skipping`);
      } else {
        try {
          if (existsSync(destPath) && force) {
            await Bun.spawn(["rm", "-rf", destPath]).exited;
          }
          const result = await Bun.spawn(["cp", "-r", sourcePath, destPath]).exited;
          if (result !== 0) {
            console.log(`  ${chalk.red("âœ—")} .codex/skills/${skill} - copy failed`);
            continue;
          }
          const action = force ? "updated" : "created";
          console.log(`  ${chalk.green("âœ“")} .codex/skills/${skill} (${action})`);
        } catch (error) {
          console.log(`  ${chalk.red("âœ—")} .codex/skills/${skill} - error: ${error}`);
        }
      }
    }
  }

  // Copy skills to .factory/skills/ if Droid (Factory) is installed
  const droidInstalled = installed.some((a) => a.name === "droid");
  if (droidInstalled) {
    console.log(chalk.dim("\nInstalling skills for Droid (Factory)..."));
    const factorySkillsDir = join(projectDir, ".factory", "skills");
    if (!existsSync(factorySkillsDir)) {
      mkdirSync(factorySkillsDir, { recursive: true });
    }

    for (const skill of skills) {
      const sourcePath = join(sourceSkillsDir, skill);
      const destPath = join(factorySkillsDir, skill);

      if (!existsSync(sourcePath)) {
        continue;
      }

      if (existsSync(destPath) && !force) {
        console.log(`  ${chalk.yellow("âš ")} .factory/skills/${skill} already exists, skipping`);
      } else {
        try {
          if (existsSync(destPath) && force) {
            await Bun.spawn(["rm", "-rf", destPath]).exited;
          }
          const result = await Bun.spawn(["cp", "-r", sourcePath, destPath]).exited;
          if (result !== 0) {
            console.log(`  ${chalk.red("âœ—")} .factory/skills/${skill} - copy failed`);
            continue;
          }
          const action = force ? "updated" : "created";
          console.log(`  ${chalk.green("âœ“")} .factory/skills/${skill} (${action})`);
        } catch (error) {
          console.log(`  ${chalk.red("âœ—")} .factory/skills/${skill} - error: ${error}`);
        }
      }
    }
  }

  // Copy commands to .claude/commands/ (for Claude Code)
  console.log(chalk.dim("\nInstalling commands..."));
  const commandsDir = join(projectDir, ".claude", "commands");
  if (!existsSync(commandsDir)) {
    mkdirSync(commandsDir, { recursive: true });
  }

  const sourceCommandsDir = join(relentlessRoot, ".claude", "commands");

  // List of commands to install (used for Claude, OpenCode, Factory, and Codex)
  const commands = [
    "relentless.analyze.md",
    "relentless.checklist.md",
    "relentless.clarify.md",
    "relentless.constitution.md",
    "relentless.implement.md",
    "relentless.plan.md",
    "relentless.specify.md",
    "relentless.tasks.md",
    "relentless.taskstoissues.md",
  ];

  if (existsSync(sourceCommandsDir)) {
    for (const command of commands) {
      const sourcePath = join(sourceCommandsDir, command);
      const destPath = join(commandsDir, command);

      if (existsSync(sourcePath)) {
        if (existsSync(destPath) && !force) {
          console.log(`  ${chalk.yellow("âš ")} .claude/commands/${command} already exists, skipping`);
        } else {
          const content = await Bun.file(sourcePath).text();
          await Bun.write(destPath, content);
          const action = existsSync(destPath) && force ? "updated" : "created";
          console.log(`  ${chalk.green("âœ“")} .claude/commands/${command} (${action})`);
        }
      }
    }
  }

  // Copy commands to .opencode/command/ if OpenCode is installed (SINGULAR!)
  if (opencodeInstalled && existsSync(sourceCommandsDir)) {
    console.log(chalk.dim("\nInstalling commands for OpenCode..."));
    const opencodeCommandsDir = join(projectDir, ".opencode", "command");
    if (!existsSync(opencodeCommandsDir)) {
      mkdirSync(opencodeCommandsDir, { recursive: true });
    }

    for (const command of commands) {
      const sourcePath = join(sourceCommandsDir, command);
      const destPath = join(opencodeCommandsDir, command);

      if (existsSync(sourcePath)) {
        if (existsSync(destPath) && !force) {
          console.log(`  ${chalk.yellow("âš ")} .opencode/command/${command} already exists, skipping`);
        } else {
          const content = await Bun.file(sourcePath).text();
          await Bun.write(destPath, content);
          const action = existsSync(destPath) && force ? "updated" : "created";
          console.log(`  ${chalk.green("âœ“")} .opencode/command/${command} (${action})`);
        }
      }
    }
  }

  // Copy commands to .factory/commands/ if Droid (Factory) is installed
  if (droidInstalled && existsSync(sourceCommandsDir)) {
    console.log(chalk.dim("\nInstalling commands for Droid (Factory)..."));
    const factoryCommandsDir = join(projectDir, ".factory", "commands");
    if (!existsSync(factoryCommandsDir)) {
      mkdirSync(factoryCommandsDir, { recursive: true });
    }

    for (const command of commands) {
      const sourcePath = join(sourceCommandsDir, command);
      const destPath = join(factoryCommandsDir, command);

      if (existsSync(sourcePath)) {
        if (existsSync(destPath) && !force) {
          console.log(`  ${chalk.yellow("âš ")} .factory/commands/${command} already exists, skipping`);
        } else {
          const content = await Bun.file(sourcePath).text();
          await Bun.write(destPath, content);
          const action = existsSync(destPath) && force ? "updated" : "created";
          console.log(`  ${chalk.green("âœ“")} .factory/commands/${command} (${action})`);
        }
      }
    }
  }

  // Copy prompts to ~/.codex/prompts/ if Codex is installed (user-level only)
  if (codexInstalled && existsSync(sourceCommandsDir)) {
    console.log(chalk.dim("\nInstalling prompts for Codex (user-level)..."));
    const homeDir = process.env.HOME || process.env.USERPROFILE || "";
    const codexPromptsDir = join(homeDir, ".codex", "prompts");
    if (!existsSync(codexPromptsDir)) {
      mkdirSync(codexPromptsDir, { recursive: true });
    }

    for (const command of commands) {
      const sourcePath = join(sourceCommandsDir, command);
      // Codex prompts are invoked as /prompts:name, so we keep the same filename
      const destPath = join(codexPromptsDir, command);

      if (existsSync(sourcePath)) {
        if (existsSync(destPath) && !force) {
          console.log(`  ${chalk.yellow("âš ")} ~/.codex/prompts/${command} already exists, skipping`);
        } else {
          const content = await Bun.file(sourcePath).text();
          await Bun.write(destPath, content);
          const action = existsSync(destPath) && force ? "updated" : "created";
          console.log(`  ${chalk.green("âœ“")} ~/.codex/prompts/${command} (${action})`);
        }
      }
    }
  }

  // Create .gemini/GEMINI.md context file if Gemini is installed
  const geminiInstalled = installed.some((a) => a.name === "gemini");
  if (geminiInstalled) {
    console.log(chalk.dim("\nInstalling context for Gemini..."));
    const geminiDir = join(projectDir, ".gemini");
    if (!existsSync(geminiDir)) {
      mkdirSync(geminiDir, { recursive: true });
    }

    const geminiContextPath = join(geminiDir, "GEMINI.md");
    const geminiContextContent = `# Relentless - Universal AI Agent Orchestrator

This project uses Relentless for feature-driven development with AI agents.

## Available Skills

The following skills are available in \`.claude/skills/\`:

- **prd** - Generate Product Requirements Documents
- **constitution** - Create project governance and coding principles
- **specify** - Create feature specifications
- **plan** - Generate technical implementation plans
- **tasks** - Generate user stories and tasks
- **checklist** - Generate quality validation checklists
- **clarify** - Resolve ambiguities in specifications
- **analyze** - Analyze consistency across artifacts
- **implement** - Execute implementation workflows
- **taskstoissues** - Convert user stories to GitHub issues

## Workflow

1. Run \`/relentless.constitution\` to create project governance
2. Run \`/relentless.specify "feature description"\` to create a feature spec
3. Run \`/relentless.plan\` to generate technical plan
4. Run \`/relentless.tasks\` to generate user stories
5. Run \`/relentless.checklist\` to generate quality checklist

## Feature Directory Structure

\`\`\`
relentless/features/<feature-name>/
â”œâ”€â”€ spec.md       # Feature specification
â”œâ”€â”€ plan.md       # Technical plan
â”œâ”€â”€ tasks.md      # User stories
â”œâ”€â”€ checklist.md  # Quality checklist
â”œâ”€â”€ prd.json      # PRD JSON (for orchestrator)
â””â”€â”€ progress.txt  # Progress log
\`\`\`

For full documentation, see: https://github.com/ArvorCo/Relentless
`;

    if (existsSync(geminiContextPath) && !force) {
      console.log(`  ${chalk.yellow("âš ")} .gemini/GEMINI.md already exists, skipping`);
    } else {
      await Bun.write(geminiContextPath, geminiContextContent);
      const action = existsSync(geminiContextPath) && force ? "updated" : "created";
      console.log(`  ${chalk.green("âœ“")} .gemini/GEMINI.md (${action})`);
    }
  }

  // Print next steps
  console.log(chalk.bold.green("\nâœ… Relentless initialized!\n"));
  console.log(chalk.dim("Structure:"));
  console.log(chalk.dim("  relentless/"));
  console.log(chalk.dim("  â”œâ”€â”€ config.json          # Configuration"));
  console.log(chalk.dim("  â”œâ”€â”€ constitution.md      # Project governance (run /relentless.constitution)"));
  console.log(chalk.dim("  â”œâ”€â”€ prompt.md            # Agent instructions (run /relentless.constitution)"));
  console.log(chalk.dim("  â””â”€â”€ features/            # Feature folders"));
  console.log(chalk.dim("      â””â”€â”€ <feature>/       # Each feature has:"));
  console.log(chalk.dim("          â”œâ”€â”€ spec.md      # Feature specification"));
  console.log(chalk.dim("          â”œâ”€â”€ plan.md      # Technical plan"));
  console.log(chalk.dim("          â”œâ”€â”€ tasks.md     # User stories"));
  console.log(chalk.dim("          â”œâ”€â”€ checklist.md # Quality checklist"));
  console.log(chalk.dim("          â”œâ”€â”€ prd.json     # PRD JSON (for orchestrator)"));
  console.log(chalk.dim("          â””â”€â”€ progress.txt # Progress log\n"));

  console.log("Next steps:");
  console.log(chalk.dim("1. Create project constitution and prompt (required):"));
  console.log(`   ${chalk.cyan("/relentless.constitution")}`);
  console.log(chalk.dim("\n2. Create a feature specification:"));
  console.log(`   ${chalk.cyan("/relentless.specify Add user authentication")}`);
  console.log(chalk.dim("\n3. Generate plan, tasks, and checklist:"));
  console.log(`   ${chalk.cyan("/relentless.plan")}`);
  console.log(`   ${chalk.cyan("/relentless.tasks")}`);
  console.log(`   ${chalk.cyan("/relentless.checklist")}`);
  console.log(chalk.dim("\n4. Convert to JSON and run:"));
  console.log(`   ${chalk.cyan("relentless convert relentless/features/NNN-feature/tasks.md --feature NNN-feature")}`);
  console.log(`   ${chalk.cyan("relentless run --feature NNN-feature --tui")}`);
  console.log("");
}

/**
 * Options for creating a feature
 */
export interface CreateFeatureOptions {
  /** Include plan.md template */
  withPlan?: boolean;
  /** Auto-number the feature directory (e.g., 001-feature-name) */
  autoNumber?: boolean;
}

/**
 * Get the next feature number by finding the highest existing number
 */
function getNextFeatureNumber(projectDir: string): number {
  const featuresDir = join(projectDir, "relentless", "features");

  if (!existsSync(featuresDir)) {
    return 1;
  }

  const features = listFeatures(projectDir);

  // Extract numbers from features with format NNN-name
  const numbers = features
    .map((feature) => {
      const match = feature.match(/^(\d{3})-/);
      return match ? parseInt(match[1], 10) : 0;
    })
    .filter((n) => n > 0);

  // Return next number (or 1 if no numbered features exist)
  return numbers.length > 0 ? Math.max(...numbers) + 1 : 1;
}

/**
 * Create a new feature folder
 */
export async function createFeature(
  projectDir: string,
  featureName: string,
  options: CreateFeatureOptions = {}
): Promise<string> {
  // Generate numbered directory name if autoNumber is enabled
  let finalFeatureName = featureName;
  if (options.autoNumber) {
    const nextNumber = getNextFeatureNumber(projectDir);
    const numberPrefix = nextNumber.toString().padStart(3, "0");
    finalFeatureName = `${numberPrefix}-${featureName}`;
  }

  const featureDir = join(projectDir, "relentless", "features", finalFeatureName);

  if (existsSync(featureDir)) {
    throw new Error(`Feature '${finalFeatureName}' already exists`);
  }

  mkdirSync(featureDir, { recursive: true });

  // Create progress.txt
  const progressPath = join(featureDir, "progress.txt");
  await Bun.write(progressPath, createProgressTemplate(finalFeatureName));

  // Copy plan.md template if requested
  if (options.withPlan) {
    const planSourcePath = join(relentlessRoot, ".claude", "skills", "plan", "templates", "plan.md");
    const planDestPath = join(featureDir, "plan.md");

    if (existsSync(planSourcePath)) {
      const planContent = await Bun.file(planSourcePath).text();
      await Bun.write(planDestPath, planContent);
    }
  }

  return featureDir;
}

/**
 * List all features
 */
export function listFeatures(projectDir: string): string[] {
  const featuresDir = join(projectDir, "relentless", "features");

  if (!existsSync(featuresDir)) {
    return [];
  }

  const entries = Bun.spawnSync(["ls", "-1", featuresDir]);
  const output = new TextDecoder().decode(entries.stdout);

  return output
    .split("\n")
    .map((s) => s.trim())
    .filter((s) => s && s !== ".gitkeep");
}
